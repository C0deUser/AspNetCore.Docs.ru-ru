---
title: Управление памятью и шаблоны в ASP.NET Core
author: rick-anderson
description: Узнайте, как управляется память в ASP.NET Core и как работает сборщик мусора (GC).
ms.author: riande
ms.custom: mvc
ms.date: 4/05/2019
uid: performance/memory
ms.openlocfilehash: b2af9cb567cdb1d7b2d0942601fcc3ebd999a5d9
ms.sourcegitcommit: 6c8cff2d6753415c4f5d2ffda88159a7f6f7431a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81440952"
---
# <a name="memory-management-and-garbage-collection-gc-in-aspnet-core"></a>Управление памятью и сбор мусора (GC) в ASP.NET Core

[Себастьен Рос](https://github.com/sebastienros) и [Рик Андерсон](https://twitter.com/RickAndMSFT)

Управление памятью является сложным, даже в управляемой инфраструктуре, как .NET. Анализ и понимание проблем памяти может быть сложной задачей. В этой статье:

* Был мотивирован много *утечки памяти* и *GC не рабочие* вопросы. Большинство из этих проблем были вызваны непониманием того, как работает потребление памяти в .NET Core, или не пониманием того, как оно измеряется.
* Демонстрирует проблематичное использование памяти и предлагает альтернативные подходы.

## <a name="how-garbage-collection-gc-works-in-net-core"></a>Как работает сбор мусора (GC) в ядро .NET

GC выделяет сегменты кучи, где каждый сегмент является смежным диапазоном памяти. Объекты, помещенные в кучу, классифицируются в одно из 3 поколений: 0, 1 или 2. Поколение определяет частоту, на которую пытается GC выпустить память на управляемых объектах, на которые приложение больше не ссылается. Более низкие пронумерованные поколения GC'd часее.

Объекты перемещаются из поколения в поколение в зависимости от их продолжительности жизни. Поскольку объекты живут дольше, они перемещаются в более высокое поколение. Как упоминалось ранее, высшие поколения GC'd реже. Краткосрочные жили объекты всегда остаются в поколении 0. Например, объекты, на которые ссылаются в течение срока службы веб-запроса, недолговечны. [Одинодвий](xref:fundamentals/dependency-injection#service-lifetimes) уровень применения обычно мигрируют в поколение 2.

При запуске приложения ASP.NET Core GC:

* Зарезервирует некоторую память для начальных сегментов кучи.
* Фиксирует небольшую часть памяти при загрузке времени выполнения.

Предыдущие выделения памяти выполняются по причинам производительности. Преимущество производительности происходит от кучи сегментов в смежной памяти.

### <a name="call-gccollect"></a>Позвоните в GC. Собирать

Вызов [GC. Сбор](xref:System.GC.Collect*) явно:

* **Не** следует делать производственные ASP.NET приложения Core.
* Полезно при расследовании утечек памяти.
* При исследовании, проверяет GC удалил все оборванные объекты из памяти, чтобы память может быть измерена.

## <a name="analyzing-the-memory-usage-of-an-app"></a>Анализ использования памяти приложения

Выделенные инструменты могут помочь в анализе использования памяти:

- Подсчет ссылок на объекты
- Измерение влияния GC на использование процессора
- Измерение пространства памяти, используемого для каждого поколения

Используйте следующие инструменты для анализа использования памяти:

* [dotnet-trace](/dotnet/core/diagnostics/dotnet-trace): может быть использован на производственных машинах.
* [Анализ использования памяти без отладчика Visual Studio](/visualstudio/profiling/memory-usage-without-debugging2)
* [Использование памяти профиля в Visual Studio](/visualstudio/profiling/memory-usage)

### <a name="detecting-memory-issues"></a>Обнаружение проблем с памятью

Диспетчер задач может быть использован, чтобы получить представление о том, сколько памяти использует ASP.NET приложение. Значение памяти менеджера задачи:

* Представляет объем памяти, используемой ASP.NET процессом.
* Включает в себя живые объекты приложения и других потребителей памяти, таких как использование нативной памяти.

Если значение памяти task Manager увеличивается бесконечно и никогда не выравнивается, у приложения есть утечка памяти. Следующие разделы демонстрируют и объясняют несколько шаблонов использования памяти.

## <a name="sample-display-memory-usage-app"></a>Пример приложения для использования памяти отображения

[Образец приложения MemoryLeak](https://github.com/sebastienros/memoryleak) доступен на GitHub. Приложение MemoryLeak:

* Включает диагностический контроллер, который собирает данные памяти в режиме реального времени и GC для приложения.
* Имеет страницу индекса, отображая данные памяти и GC. Страница Индекса обновляется каждую секунду.
* Содержит контроллер API, который обеспечивает различные шаблоны нагрузки памяти.
* Не поддерживается инструмент, однако, он может быть использован для отображения памяти использования моделей ASP.NET основных приложений.

Выполнить MemoryLeak. Выделенная память медленно увеличивается до тех пор, пока не произойдет GC. Память увеличивается, потому что инструмент выделяет пользовательский объект для сбора данных. Следующее изображение показывает страницу индекса MemoryLeak, когда происходит Gen 0 GC. Диаграмма показывает 0 RPS (Запросы в секунду), потому что не были вызваны конечные точки API от контроллера API.

![предшествующая диаграмма](memory/_static/0RPS.png)

Диаграмма отображает два значения для использования памяти:

- Выделено: объем памяти, занимаемой управляемыми объектами
- [Рабочий набор](/windows/win32/memory/working-set): Набор страниц в виртуальном адресном пространстве процесса, которые в настоящее время обитают в физической памяти. Показанный рабочий набор — это одно и то же значение, отображаемый менеджером задач.

### <a name="transient-objects"></a>Переходные объекты

Следующий API создает экземпляр 10-KB String и возвращает его клиенту. По каждому запросу новый объект выделяется в памяти и записываются в ответ. Строки хранятся как символы UTF-16 в .NET, поэтому каждый символ занимает 2 байта в памяти.

```csharp
[HttpGet("bigstring")]
public ActionResult<string> GetBigString()
{
    return new String('x', 10 * 1024);
}
```

Следующий график генерируется с относительно небольшой нагрузкой, чтобы показать, как распределение памяти влияет на GC.

![предшествующая диаграмма](memory/_static/bigstring.png)

Предыдущая диаграмма показывает:

* 4K RPS (Запросы в секунду).
* Коллекции GC поколения 0 происходят примерно каждые две секунды.
* Рабочий набор является постоянным на уровне примерно 500 МБ.
* Процессор составляет 12%.
* Потребление и высвобождение памяти (через GC) стабильно.

Следующая диаграмма взята на максимальной пропускной связи, которая может быть обработана машиной.

![предшествующая диаграмма](memory/_static/bigstring2.png)

Предыдущая диаграмма показывает:

* 22K RPS
* Коллекции GC поколения 0 встречаются несколько раз в секунду.
* Коллекции поколения 1 срабатывают, потому что приложение выделяет значительно больше памяти в секунду.
* Рабочий набор является постоянным на уровне примерно 500 МБ.
* Процессор составляет 33%.
* Потребление и высвобождение памяти (через GC) стабильно.
* Процессор (33%) не используется чрезмерно, поэтому сбор мусора может идти в ногу с большим количеством ассигнований.

### <a name="workstation-gc-vs-server-gc"></a>Рабочая станция GC против сервера GC

Сборщик мусора .NET имеет два различных режима:

* **Рабочая станция GC**: Оптимизирована для рабочего стола.
* **Сервер GC**. GC по умолчанию для ASP.NET основных приложений. Оптимизирован для сервера.

Режим GC может быть установлен явно в файле проекта или в файле *runtimeconfig.json* опубликованного приложения. Следующая разметка `ServerGarbageCollection` показывает настройку в файле проекта:

```xml
<PropertyGroup>
  <ServerGarbageCollection>true</ServerGarbageCollection>
</PropertyGroup>
```

Изменение `ServerGarbageCollection` файла проекта требует перестроения приложения.

**Примечание:** Сбор мусора сервера **недоступен** на машинах с одним ядром. Для получения дополнительной информации см. <xref:System.Runtime.GCSettings.IsServerGC>.

Следующее изображение показывает профиль памяти под 5K RPS с помощью Рабочей станции GC.

![предшествующая диаграмма](memory/_static/workstation.png)

Различия между этой диаграммой и серверной версией значительны:

- Рабочий набор падает с 500 МБ до 70 МБ.
- GC делает коллекции поколения 0 несколько раз в секунду вместо каждых двух секунд.
- GC падает с 300 МБ до 10 МБ.

В типичной среде веб-сервера использование процессора важнее памяти, поэтому GC сервера лучше. Если использование памяти является высоким и использование процессора является относительно низким, Workstation GC может быть более performant. Например, высокая плотность хостинга нескольких веб-приложений, где память не хватает.

<a name="sc"></a>

### <a name="gc-using-docker-and-small-containers"></a>GC с использованием Docker и небольших контейнеров

Когда несколько контейнеризированных приложений работают на одной машине, Workstation GC может быть более пререформантным, чем Server GC. Для получения дополнительной информации [см. Запуск с сервером GC в небольшом контейнере](https://devblogs.microsoft.com/dotnet/running-with-server-gc-in-a-small-container-scenario-part-0/) и [запуск с сервером GC в малом контейнерном сценарии Часть 1 - жесткий предел для GC Heap](https://devblogs.microsoft.com/dotnet/running-with-server-gc-in-a-small-container-scenario-part-1-hard-limit-for-the-gc-heap/).

### <a name="persistent-object-references"></a>Стойкие ссылки на объекты

GC не может освободить объекты, на которые ссылаются. Объекты, на которые ссылаются, но больше не нужны, приводят к утечке памяти. Если приложение часто выделяет объекты и не освобождает их после того, как они больше не нужны, использование памяти будет увеличиваться с течением времени.

Следующий API создает экземпляр 10-KB String и возвращает его клиенту. Разница с предыдущим примером заключается в том, что на этот экземпляр ссылается статический участник, что означает, что он никогда не доступен для сбора.

```csharp
private static ConcurrentBag<string> _staticStrings = new ConcurrentBag<string>();

[HttpGet("staticstring")]
public ActionResult<string> GetStaticString()
{
    var bigString = new String('x', 10 * 1024);
    _staticStrings.Add(bigString);
    return bigString;
}
```

Предыдущий код:

* Является примером типичной утечки памяти.
* При частых звонках память приложения увеличивается до `OutOfMemory` тех пор, пока процесс не сбоит с поломкой, за исключением.

![предшествующая диаграмма](memory/_static/eternal.png)

На предыдущем изображении:

* Нагрузка `/api/staticstring` тестирования конечная точка вызывает линейное увеличение памяти.
* GC пытается освободить память по мере роста давления памяти, вызывая коллекцию поколения 2.
* GC не может освободить просочивную память. Выделенный и рабочий набор увеличивается со временем.

Некоторые сценарии, такие как кэширование, требуют, чтобы ссылки объектов удерживаются до тех пор, пока давление памяти не заставить их быть освобожденным. Класс <xref:System.WeakReference> может быть использован для этого типа кода кэширования. Объект `WeakReference` собирается под давлением памяти. Реализация <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> использования `WeakReference`по умолчанию.

### <a name="native-memory"></a>Родные памяти

Некоторые объекты .NET Core полагаются на родную память. Родные памяти **не** могут быть собраны GC. Объект .NET, использующий нативную память, должен освободить его с помощью родного кода.

.NET предоставляет <xref:System.IDisposable> интерфейс, чтобы позволить разработчикам выпустить родную память. Даже <xref:System.IDisposable.Dispose*> если не вызывается, правильно `Dispose` реализованы классы вызова при [запуске finalizer.](/dotnet/csharp/programming-guide/classes-and-structs/destructors)

Рассмотрим следующий код.

```csharp
[HttpGet("fileprovider")]
public void GetFileProvider()
{
    var fp = new PhysicalFileProvider(TempPath);
    fp.Watch("*.*");
}
```

[PhysicalFileProvider](/dotnet/api/microsoft.extensions.fileproviders.physicalfileprovider?view=dotnet-plat-ext-3.0) является управляемым классом, поэтому любой экземпляр будет собран в конце запроса.

Следующее изображение показывает профиль памяти `fileprovider` при постоянном входе в API.

![предшествующая диаграмма](memory/_static/fileprovider.png)

Предыдущая диаграмма показывает очевидную проблему с реализацией этого класса, так как она продолжает увеличивать использование памяти. Это известная проблема, которая отслеживается в [этом вопросе.](https://github.com/dotnet/aspnetcore/issues/3110)

Такая же утечка может произойти в пользовательском коде, одним из следующих:

* Неправильно выпускать класс.
* Забыв вызвать `Dispose`метод зависимых объектов, которые должны быть удалены.

### <a name="large-objects-heap"></a>Куча крупных объектов

Частое распределение памяти/свободные циклы могут фрагментировать память, особенно при выделении больших фрагментов памяти. Объекты распределяются в смежных блоках памяти. Чтобы уменьшить фрагментацию, когда GC освобождает память, он пытается дефрагментировать его. Этот процесс называется **уплотнение**. Компишн включает в себя перемещение объектов. Перемещение крупных объектов налагает штраф за производительность. По этой причине GC создает специальную зону памяти для _крупных_ объектов, [называемую большой объектной кучи](/dotnet/standard/garbage-collection/large-object-heap) (LOH). Объекты, превышаюющие 85 000 байтов (примерно 83 кБ), являются:

* Размещено на LOH.
* Не уплотнен.
* Собрано во время поколения 2 ГК.

Когда LOH полон, GC запустит коллекцию поколения 2. Коллекции поколения 2:

* По своей сути медленно.
* Кроме того, понесет расходы на запуск коллекции на всех других поколениях.

Следующий код уплотняет LOH немедленно:

```csharp
GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
GC.Collect();
```

Смотрите <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode> для получения информации о уплотнении LOH.

В контейнерах с использованием .NET Core 3.0 и позже LOH автоматически уплотняется.

Следующий API, иллюстрирующий такое поведение:

```csharp
[HttpGet("loh/{size=85000}")]
public int GetLOH1(int size)
{
   return new byte[size].Length;
}
```

На следующем графике показан профиль `/api/loh/84975` памяти вызова конечной точки при максимальной нагрузке:

![предшествующая диаграмма](memory/_static/loh1.png)

На следующем графике показан профиль `/api/loh/84976` памяти вызова конечной точки, выделяя *еще один байт:*

![предшествующая диаграмма](memory/_static/loh2.png)

Примечание: `byte[]` Структура имеет накладные байты. Вот почему 84 976 байтов вызывает 85000 предел.

Сравнение двух предыдущих диаграмм:

* Рабочий набор схож для обоих сценариев, около 450 МБ.
* Под запросами LOH (84,975 байтов) показывает в основном коллекции поколения 0.
* Запросы over LOH генерируют постоянные коллекции поколения 2. Коллекции поколения 2 стоят дорого. Требуется больше процессора и пропускная часть падает почти на 50%.

Временные крупные объекты особенно проблематичны, поскольку они вызывают gCs gen2.

Для максимальной производительности использование больших объектов должно быть сведено к минимуму. Если возможно, разделите крупные объекты. Например, [промежуточное](xref:performance/caching/response) программное обеспечение Response Caching в ASP.NET Core разделило записи кэша на блоки менее 85 000 байтов.

Следующие ссылки показывают ASP.NET основной подход к поддержанию объектов под пределом LOH:

* [ResponseCaching/Streams/StreamUtilities.cs](https://github.com/dotnet/AspNetCore/blob/v3.0.0/src/Middleware/ResponseCaching/src/Streams/StreamUtilities.cs#L16)
* [ОтветКэшинг/MemoryResponseCache.cs](https://github.com/aspnet/ResponseCaching/blob/c1cb7576a0b86e32aec990c22df29c780af29ca5/src/Microsoft.AspNetCore.ResponseCaching/Internal/MemoryResponseCache.cs#L55)

Дополнительные сведения см. в разделе:

* [Большая куча объектов Нераскрытая](https://devblogs.microsoft.com/dotnet/large-object-heap-uncovered-from-an-old-msdn-article/)
* [Большая объектная куча](/dotnet/standard/garbage-collection/large-object-heap)

### <a name="httpclient"></a>HttpClient

Неправильное <xref:System.Net.Http.HttpClient> использование может привести к утечке ресурсов. Системные ресурсы, такие как соединения баз данных, розетки, обработки файлов и т.д.:

* Более скудны, чем память.
* Являются более проблематичными при утечке, чем память.

Опытные разработчики .NET знают, что они вызывают <xref:System.IDisposable.Dispose*> объекты, которые реализуются. <xref:System.IDisposable> Неутилизация объектов, `IDisposable` которые реализуются обычно приводит к утечке памяти или утечке системных ресурсов.

`HttpClient``IDisposable`реализует, но **не** должен быть удален на каждом вызове. Скорее, `HttpClient` должны быть использованы повторно.

Следующая конечная точка создает `HttpClient` и распоряжается новым экземпляром по каждому запросу:

```csharp
[HttpGet("httpclient1")]
public async Task<int> GetHttpClient1(string url)
{
    using (var httpClient = new HttpClient())
    {
        var result = await httpClient.GetAsync(url);
        return (int)result.StatusCode;
    }
}
```

При загрузке регистрируются следующие сообщения об ошибках:

```
fail: Microsoft.AspNetCore.Server.Kestrel[13]
      Connection id "0HLG70PBE1CR1", Request id "0HLG70PBE1CR1:00000031":
      An unhandled exception was thrown by the application.
System.Net.Http.HttpRequestException: Only one usage of each socket address
    (protocol/network address/port) is normally permitted --->
    System.Net.Sockets.SocketException: Only one usage of each socket address
    (protocol/network address/port) is normally permitted
   at System.Net.Http.ConnectHelper.ConnectAsync(String host, Int32 port,
    CancellationToken cancellationToken)
```

Несмотря `HttpClient` на то, что экземпляры удалены, фактическое подключение к сети занимает некоторое время, чтобы быть освобожденным операционной системой. Непрерывно создавая новые соединения, происходит _истощение портов._ Каждое клиентское соединение требует своего порта клиента.

Одним из способов предотвращения исчерпания `HttpClient` порта является повторное использование одного и того же экземпляра:

```csharp
private static readonly HttpClient _httpClient = new HttpClient();

[HttpGet("httpclient2")]
public async Task<int> GetHttpClient2(string url)
{
    var result = await _httpClient.GetAsync(url);
    return (int)result.StatusCode;
}
```

Экземпляр `HttpClient` освобождается, когда приложение останавливается. Этот пример показывает, что не каждый одноразовый ресурс должен быть удален после каждого использования.

Смотрите следующий способ лучшего способа обработки жизни экземпляра: `HttpClient`

* [Управление HttpClient и временем существования](/aspnet/core/fundamentals/http-requests#httpclient-and-lifetime-management)
* [Блог фабрики HTTPClient](https://devblogs.microsoft.com/aspnet/asp-net-core-2-1-preview1-introducing-httpclient-factory/)
 
### <a name="object-pooling"></a>Объединение объектов

Предыдущий пример показал, как `HttpClient` экземпляр может быть статичен и повторно использован всеми запросами. Повторное использование предотвращает иссяке ресурсы.

Объединение объектов:

* Использует шаблон повторного использования.
* Предназначен для объектов, которые являются дорогостоящими для создания.

Пул представляет собой набор предварительно инициализированных объектов, которые могут быть зарезервированы и выпущены между потоками. Пулы могут определять правила распределения, такие как ограничения, предопределенные размеры или темпы роста.

Пакет NuGet [Microsoft.Extensions.ObjectPool](https://www.nuget.org/packages/Microsoft.Extensions.ObjectPool/) содержит классы, которые помогают управлять такими пулами.

Следующая конечная точка API `byte` мгновенно выполняет буфер, наполненный случайными числами по каждому запросу:

```csharp
        [HttpGet("array/{size}")]
        public byte[] GetArray(int size)
        {
            var random = new Random();
            var array = new byte[size];
            random.NextBytes(array);

            return array;
        }
```

Следующий отображение диаграммы, вызывающее предыдущий API с умеренной нагрузкой:

![предшествующая диаграмма](memory/_static/array.png)

В предыдущем графике коллекции поколения 0 происходят примерно раз в секунду.

Предыдущий код можно оптимизировать `byte` путем объединения буфера с помощью [ArrayPool\<T>. ](xref:System.Buffers.ArrayPool`1) Статический экземпляр используется повторно по запросам.

Отличие этого подхода заключается в том, что объединенный объект возвращается из API. Это означает:

* Объект находится вне вашего контроля, как только вы вернетесь из метода.
* Вы не можете освободить объект.

Для настройки утилизации объекта:

* Инкапсулировать объединенный массив в одноразовый объект.
* Зарегистрируйте объединенный объект с [помощью httpContext.Response.RegisterFordispose](xref:Microsoft.AspNetCore.Http.HttpResponse.RegisterForDispose*).

`RegisterForDispose`будет заботиться `Dispose`о вызове на целевой объект, так что он только выпущен, когда запрос HTTP завершен.

```csharp
private static ArrayPool<byte> _arrayPool = ArrayPool<byte>.Create();

private class PooledArray : IDisposable
{
    public byte[] Array { get; private set; }

    public PooledArray(int size)
    {
        Array = _arrayPool.Rent(size);
    }

    public void Dispose()
    {
        _arrayPool.Return(Array);
    }
}

[HttpGet("pooledarray/{size}")]
public byte[] GetPooledArray(int size)
{
    var pooledArray = new PooledArray(size);

    var random = new Random();
    random.NextBytes(pooledArray.Array);

    HttpContext.Response.RegisterForDispose(pooledArray);

    return pooledArray.Array;
}
```

Применение той же нагрузки, что и необъединенная версия, приводит к следующему графику:

![предшествующая диаграмма](memory/_static/pooledarray.png)

Основное отличие выделяется байтами, и, как следствие, гораздо меньше коллекций поколения 0.

## <a name="additional-resources"></a>Дополнительные ресурсы

* [Сборка мусора](/dotnet/standard/garbage-collection/)
* [Понимание различных режимов GC с помощью конпартайзера](https://blogs.msdn.microsoft.com/seteplia/2017/01/05/understanding-different-gc-modes-with-concurrency-visualizer/)
* [Большая куча объектов Нераскрытая](https://devblogs.microsoft.com/dotnet/large-object-heap-uncovered-from-an-old-msdn-article/)
* [Большая объектная куча](/dotnet/standard/garbage-collection/large-object-heap)
