---
title: Снять защиту с полезных данных, ключи которых были отозваны в ASP.NET Core
author: rick-anderson
description: Узнайте, как снять защиту данных, защищенных с помощью ключей, которые были отозваны в ASP.NET Core приложении.
ms.author: riande
ms.custom: mvc
ms.date: 10/24/2018
no-loc:
- Blazor
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/consumer-apis/dangerous-unprotect
ms.openlocfilehash: 062703fc72ab4e515a99558b3316070ce1f83f79
ms.sourcegitcommit: 70e5f982c218db82aa54aa8b8d96b377cfc7283f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2020
ms.locfileid: "82776803"
---
# <a name="unprotect-payloads-whose-keys-have-been-revoked-in-aspnet-core"></a>Снять защиту с полезных данных, ключи которых были отозваны в ASP.NET Core

<a name="data-protection-consumer-apis-dangerous-unprotect"></a>

ASP.NET Core API-интерфейсы защиты данных в основном не предназначены для неопределенного сохранения конфиденциальных полезных данных. Другие технологии, такие как [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) и [Azure Rights Management](/rights-management/) , более подходят для сценария неопределенного хранилища и имеют соответствующие возможности управления ключами. С другой стороны, разработчик не запрещает использовать ASP.NET Core API-интерфейсы защиты данных для долгосрочной защиты конфиденциальных данных. Ключи никогда не удаляются из кольца ключей, поэтому `IDataProtector.Unprotect` всегда могут восстанавливать существующие полезные данные, если ключи доступны и действительны.

Однако проблема возникает, когда разработчик пытается снять защиту с данных, защищенных с помощью отозванного ключа, так как `IDataProtector.Unprotect` в этом случае будет выдано исключение. Это может быть удобно для кратковременных или временных полезных данных (например, маркеров проверки подлинности), так как эти типы полезных данных могут легко воссоздаться системой, и в худшем случае посетителям сайта может потребоваться снова войти в систему. Но для сохраненных полезных данных использование `Unprotect` Throw может привести к неприемлемой потери данных.

## <a name="ipersisteddataprotector"></a>иперсистеддатапротектор

Для поддержки сценария, позволяющего снять защиту полезных данных даже в случае отозванных ключей, система защиты данных содержит `IPersistedDataProtector` тип. Чтобы `IPersistedDataProtector`получить экземпляр, просто получите `IDataProtector` экземпляр обычным образом и попробуйте приведение `IDataProtector` к. `IPersistedDataProtector`

> [!NOTE]
> Не все `IDataProtector` экземпляры могут быть приведены к `IPersistedDataProtector`. Разработчики должны использовать оператор C# AS или аналогичный, чтобы избежать исключений среды выполнения, вызванных недопустимыми приведениями, и должны быть готовы к обработке случайного сбоя.

`IPersistedDataProtector`предоставляет следующую поверхность API:

```csharp
DangerousUnprotect(byte[] protectedData, bool ignoreRevocationErrors,
     out bool requiresMigration, out bool wasRevoked) : byte[]
```

Этот API принимает защищенные полезные данные (в виде массива байтов) и возвращает незащищенные полезные данные. Перегрузка на основе строк отсутствует. Ниже приведены два выходных параметра.

* `requiresMigration`: будет иметь значение true, если ключ, используемый для защиты этих полезных данных, больше не является активным ключом по умолчанию, например, ключ, используемый для защиты этой полезной нагрузки, устарел и операция с предыдущим ключом уже выполнена. Вызывающий объект может попытаться повторно защитить полезные данные в зависимости от бизнес-потребностей.

* `wasRevoked`: будет иметь значение true, если ключ, используемый для защиты полезной нагрузки, был отозван.

>[!WARNING]
> При передаче `ignoreRevocationErrors: true` в `DangerousUnprotect` метод Будьте предельно осторожны. Если после вызова этого метода `wasRevoked` значение равно true, то ключ, используемый для защиты этих полезных данных, был отозван, а подлинность полезной нагрузки должна рассматриваться как подозрительная. В этом случае продолжайте работать только с незащищенными полезными данными, только если у вас есть отдельная гарантия, которую она подлинна, например, она поступает из защищенной базы данных, а не отправляется недоверенным веб-клиентом.

[!code-csharp[](dangerous-unprotect/samples/dangerous-unprotect.cs)]
