---
title: Безопасные Blazor приложения ASP.NET Core Server
author: guardrex
description: Узнайте, как уменьшить Blazor угрозы безопасности для приложений Сервера.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 04/02/2020
no-loc:
- Blazor
- SignalR
uid: security/blazor/server
ms.openlocfilehash: bd03f811d0425fdfdb7bbbc24fea5481b49b8ed3
ms.sourcegitcommit: 9675db7bf4b67ae269f9226b6f6f439b5cce4603
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/03/2020
ms.locfileid: "80626024"
---
# <a name="secure-aspnet-core-blazor-server-apps"></a>Безопасные приложения ASP.NET Основный Blazor Server

Хавьер [Кальварро Нельсон](https://github.com/javiercn)

Приложения Blazor Server внедряли модель *обработки данных,* в которой сервер и клиент поддерживают долгосрочные отношения. Постоянное состояние поддерживается [цепью,](xref:blazor/state-management)которая может охватывать соединения, которые также потенциально долгоживущие.

Когда пользователь посещает сайт Blazor Server, сервер создает схему в памяти сервера. Схема показывает браузеру, какое содержимое отображать и реагировать на события, например, когда пользователь выбирает кнопку в пользовательском интерфейсе. Для выполнения этих действий схема вызывает функции JavaScript в браузере пользователя и методы .NET на сервере. Это двустороннее взаимодействие на основе JavaScript называется [Interop JavaScript (JS interop).](xref:blazor/call-javascript-from-dotnet)

Поскольку JS interop происходит через Интернет и клиент использует удаленный браузер, приложения Blazor Server разделяют большинство проблем безопасности веб-приложений. Эта тема описывает общие угрозы для приложений Blazor Server и предоставляет рекомендации по смягчению угроз, ориентированные на приложения, ориентированные на Интернет.

В ограниченных средах, таких как внутри корпоративных сетей или интрасетей, некоторые из руководящих принципов смягчения либо:

* Не применяется в ограниченной среде.
* Не стоит затрат на реализацию, так как риск безопасности является низким в ограниченной среде.

## <a name="blazor-server-project-template"></a>Шаблон проекта Blazor Server

Шаблон проекта Blazor Server может быть настроен для проверки подлинности при создании проекта.

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

Следуйте указаниям по работе с Visual Studio (<xref:blazor/get-started>), чтобы создать проект Blazor на стороне сервера с механизмом аутентификации.

Выбрав шаблон **Серверное приложение Blazor** в диалоговом окне **Создать веб-приложение ASP.NET Core**, щелкните **Изменить** в разделе **Проверка подлинности**.

Откроется диалоговое окно с тем же набором механизмов аутентификации, которые доступны для других проектов ASP.NET Core.

* **Отсутствие аутентификации**
* **** Учетные записи отдельных пользователей&ndash;, которые можно хранить следующим образом:
  * в приложении с помощью системы [удостоверений](xref:security/authentication/identity) ASP.NET Core;
  * в [Azure AD B2C](xref:security/authentication/azure-ad-b2c);
* **Рабочие или школьные счета**
* **Проверка подлинности Windows**

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

Следуйте указаниям по работе с Visual Studio Code (<xref:blazor/get-started>), чтобы создать проект Blazor на стороне сервера с механизмом аутентификации.

```dotnetcli
dotnet new blazorserver -o {APP NAME} -au {AUTHENTICATION}
```

Допустимые значения аутентификации (`{AUTHENTICATION}`) перечислены в следующей таблице.

| Механизм аутентификации                                                                 | Значение `{AUTHENTICATION}` |
| ---------------------------------------------------------------------------------------- | :----------------------: |
| Без аутентификации                                                                        | `None`                   |
| Индивидуальное лицо<br>Пользователи, сохраненные в приложении с помощью ASP.NET Core Identity                        | `Individual`             |
| Индивидуальное лицо<br>Пользователи, сохраненные в [Azure AD B2C](xref:security/authentication/azure-ad-b2c). | `IndividualB2C`          |
| Рабочие или учебные учетные записи<br>Корпоративная аутентификация для отдельного клиента.            | `SingleOrg`              |
| Рабочие или учебные учетные записи<br>Корпоративная аутентификация для нескольких клиентов.           | `MultiOrg`               |
| Проверка подлинности Windows                                                                   | `Windows`                |

Эта команда создает папку, в качестве имени для которой берется значение, предоставленное вместо заполнителя `{APP NAME}`, а затем использует имя папки в качестве имени приложения. Подробнее см. статью о команде [dotnet new](/dotnet/core/tools/dotnet-new) в руководстве по .NET Core.

# <a name="visual-studio-for-mac"></a>[Visual Studio для Mac](#tab/visual-studio-mac)

1. Следуйте Visual Studio для Mac <xref:blazor/get-started> руководство в статье.

1. На **настройке нового** шага Blazor Server App выберите **индивидуальную аутентификацию (в приложении)** из уровня **аутентификации.**

1. Приложение создано для отдельных пользователей, хранящихся в приложении с ASP.NET Core Identity.

# <a name="net-core-cli"></a>[Интерфейс командной строки .NET Core](#tab/netcore-cli/)

Следуйте руководству .NET Core CLI в <xref:blazor/get-started> статье, чтобы создать новый проект Blazor Server с механизмом аутентификации:

```dotnetcli
dotnet new blazorserver -o {APP NAME} -au {AUTHENTICATION}
```

Допустимые значения аутентификации (`{AUTHENTICATION}`) перечислены в следующей таблице.

| Механизм аутентификации                                                                 | Значение `{AUTHENTICATION}` |
| ---------------------------------------------------------------------------------------- | :----------------------: |
| Без аутентификации                                                                        | `None`                   |
| Индивидуальное лицо<br>Пользователи, сохраненные в приложении с помощью ASP.NET Core Identity                        | `Individual`             |
| Индивидуальное лицо<br>Пользователи, сохраненные в [Azure AD B2C](xref:security/authentication/azure-ad-b2c). | `IndividualB2C`          |
| Рабочие или учебные учетные записи<br>Корпоративная аутентификация для отдельного клиента.            | `SingleOrg`              |
| Рабочие или учебные учетные записи<br>Корпоративная аутентификация для нескольких клиентов.           | `MultiOrg`               |
| Проверка подлинности Windows                                                                   | `Windows`                |

Эта команда создает папку, в качестве имени для которой берется значение, предоставленное вместо заполнителя `{APP NAME}`, а затем использует имя папки в качестве имени приложения. Подробнее см. статью о команде [dotnet new](/dotnet/core/tools/dotnet-new) в руководстве по .NET Core.

---

## <a name="pass-tokens-to-a-blazor-server-app"></a>Передайте токены в приложение Blazor Server

Authenticate приложение Blazor Server, как вы бы с обычным Razor Страницы или MVC приложение. Предоставление и сохранение маркеров в файле проверки подлинности. Пример:

```csharp
using Microsoft.AspNetCore.Authentication.OpenIdConnect;

...

services.Configure<OpenIdConnectOptions>(AzureADDefaults.OpenIdScheme, options =>
{
    options.ResponseType = "code";
    options.SaveTokens = true;

    options.Scope.Add("offline_access");
    options.Scope.Add("{SCOPE}");
    options.Resource = "{RESOURCE}";
});
```

Для примера кода, `Startup.ConfigureServices` включая [Passing tokens to a server-side Blazor application](https://github.com/javiercn/blazor-server-aad-sample)полный пример, см.

Определите класс для прохождения в исходном состоянии приложения с помощью токенов доступа и обновления:

```csharp
public class InitialApplicationState
{
    public string AccessToken { get; set; }
    public string RefreshToken { get; set; }
}
```

Определите **объем** услуг поставщика токенов, который может быть использован в приложении Blazor для устранения токенов из DI:

```csharp
using System;
using System.Security.Claims;
using System.Threading.Tasks;

public class TokenProvider
{
    public string AccessToken { get; set; }
    public string RefreshToken { get; set; }
}
```

В, `Startup.ConfigureServices`добавить услуги для:

* `IHttpClientFactory`
* `TokenProvider`

```csharp
services.AddHttpClient();
services.AddScoped<TokenProvider>();
```

В файле *_Host.cshtml* создайте `InitialApplicationState` и передайте его в качестве параметра приложению:

```cshtml
@using Microsoft.AspNetCore.Authentication

...

@{
    var tokens = new InitialApplicationState
    {
        AccessToken = await HttpContext.GetTokenAsync("access_token"),
        RefreshToken = await HttpContext.GetTokenAsync("refresh_token")
    };
}

<app>
    <component type="typeof(App)" param-InitialState="tokens" 
        render-mode="ServerPrerendered" />
</app>
```

В `App` компоненте (*App.razor*), решить службы и инициализировать его с данными из параметра:

```razor
@inject TokenProvider TokensProvider

...

@code {
    [Parameter]
    public InitialApplicationState InitialState { get; set; }

    protected override Task OnInitializedAsync()
    {
        TokensProvider.AccessToken = InitialState.AccessToken;
        TokensProvider.RefreshToken = InitialState.RefreshToken;

        return base.OnInitializedAsync();
    }
}
```

В службе, которая делает безопасный запрос API, введите поставщика маркеров и извлеките маркер для вызова API:

```csharp
public class WeatherForecastService
{
    private readonly TokenProvider _store;

    public WeatherForecastService(IHttpClientFactory clientFactory, 
        TokenProvider tokenProvider)
    {
        Client = clientFactory.CreateClient();
        _store = tokenProvider;
    }

    public HttpClient Client { get; }

    public async Task<WeatherForecast[]> GetForecastAsync(DateTime startDate)
    {
        var token = _store.AccessToken;
        var request = new HttpRequestMessage(HttpMethod.Get, 
            "https://localhost:5003/WeatherForecast");
        request.Headers.Add("Authorization", $"Bearer {token}");
        var response = await Client.SendAsync(request);
        response.EnsureSuccessStatusCode();

        return await response.Content.ReadAsAsync<WeatherForecast[]>();
    }
}
```

## <a name="resource-exhaustion"></a>Исчерпание ресурсов

Исчерпание ресурсов может произойти, когда клиент взаимодействует с сервером и заставляет сервер потреблять избыточные ресурсы. Чрезмерное потребление ресурсов в первую очередь влияет на:

* [Процессора](#cpu)
* [Память](#memory)
* [Клиентские подключения](#client-connections)

Атаки отказов в обслуживании (DoS) обычно направлены на исчерпание ресурсов приложения или сервера. Однако исчерпание ресурсов не обязательно является результатом атаки на систему. Например, ограниченные ресурсы могут быть исчерпаны из-за высокого спроса пользователей. DoS дополнительно покрывается в разделе [атак «Отказ в обслуживании» (DoS).](#denial-of-service-dos-attacks)

Ресурсы, не внерами к инфраструктуре Blazor, такие как базы данных и обработки файлов (используется для чтения и записи файлов), также могут испытывать истощение ресурсов. Для получения дополнительной информации см. <xref:performance/performance-best-practices>.

### <a name="cpu"></a>ЦП

Исчерпание процессора может произойти, когда один или несколько клиентов заставляют сервер выполнять интенсивную работу процессора.

Например, рассмотрим приложение Blazor Server, которое вычисляет *номер Fibonnacci.* Номер Фибонначчи производится из последовательности Фибонначчи, где каждое число в последовательности является суммой двух предыдущих чисел. Объем работы, необходимый для достижения ответа, зависит от длины последовательности и размера исходного значения. Если приложение не ограничивает запрос клиента, расчеты, интенсивные для процессора, могут доминировать во времени процессора и снижать производительность других задач. Чрезмерное потребление ресурсов является проблемой безопасности, влияющих на доступность.

Исчерпание процессора является проблемой для всех общедоступных приложений. В обычных веб-приложениях запросы и подключения продлятесь в качестве гарантии, но приложения Blazor Server не обеспечивают одинаковых гарантий. Приложения Blazor Server должны включать соответствующие проверки и ограничения перед выполнением потенциально интенсивной работы с процессором.

### <a name="memory"></a>Память

Исчерпание памяти может произойти, когда один или несколько клиентов заставляют сервер потреблять большое количество памяти.

Например, рассмотрим боковое приложение Blazor-server с компонентом, который принимает и отображает список элементов. Если приложение Blazor не ограничивает количество разрешенных элементов или количество элементов, отображаемых клиенту, интенсивная обработка и визуализация памяти может доминировать в памяти сервера до такой степени, что производительность сервера страдает. Сервер может выйти из строя или замедлиться до такой степени, что он, как представляется, разбился.

Рассмотрим следующий сценарий для поддержания и отображения списка элементов, относящихся к сценарию истощения памяти на сервере:

* Элементы в `List<MyItem>` свойстве или поле используют память сервера. Если приложение позволяет списку элементов расти неограниченно, есть риск того, что у сервера не будет памяти. Запуск из памяти приводит к окончанию текущего сеанса (авария), и все параллельные сеансы в экземпляре сервера получают исключение из непамяти. Чтобы предотвратить возникновение этого сценария, приложение должно использовать структуру данных, которая накладывает ограничение элемента на одновременных пользователей.
* Если схема paging не используется для рендеринга, сервер использует дополнительную память для объектов, которые не видны в системе обработки. Без ограничения количества элементов требования к памяти могут исчерпать доступную память сервера. Чтобы предотвратить этот сценарий, используйте один из следующих подходов:
  * Используйте paginated списки при визуализации.
  * Отображайте только первые 100-1000 элементов и требуйте от пользователя ввести критерии поиска, чтобы найти элементы за пределами отображаемых элементов.
  * Для более продвинутого сценария визуализации реализуйте списки или сетки, *поддерживающие виртуализацию.* Используя виртуализацию, списки только визуализации подмножество элементов в настоящее время видны пользователю. Когда пользователь взаимодействует с панелью прокрутки в пользовательском интерфейсе, компонент отображает только те элементы, которые необходимы для отображения. Элементы, которые в настоящее время не требуются для отображения, могут храниться во вторичном хранилище, что является идеальным подходом. Неотображенные элементы также могут быть в памяти, что является менее идеальным.

Приложения Blazor Server предлагают аналогичную модель программирования для других платформ uI для приложений с состоянием, таких как WPF, Windows Forms или Blazor Web Assembly. Основное отличие заключается в том, что в нескольких средах uI память, потребляемая приложением, принадлежит клиенту и влияет только на этого отдельного клиента. Например, приложение Blazor WebAssembly работает полностью на клиенте и использует только ресурсы памяти клиента. В сценарии Blazor Server память, потребляемая приложением, принадлежит серверу и распределяется между клиентами на экземпляре сервера.

Требования к памяти на стороне сервера являются соображениями для всех приложений Blazor Server. Однако большинство веб-приложений являются апосильными, и память, используемая при обработке запроса, освобождается при возврате ответа. В качестве общей рекомендации не позволяйте клиентам выделять неограниченное количество памяти, как в любом другом приложении на стороне сервера, которое сохраняет сятные клиентские соединения. Память, потребляемая приложением Blazor Server, сохраняется дольше, чем один запрос.

> [!NOTE]
> Во время разработки можно использовать профайлер или отслеживать, чтобы оценить требования клиентов к памяти. Профайлер или трассировка не захватит память, выделенную определенному клиенту. Чтобы запечатлеть использование памяти конкретного клиента во время разработки, захват свалки и изучить требование памяти всех объектов, коренится в цепи пользователя.

### <a name="client-connections"></a>Клиентские подключения

Исчерпание связи может произойти, когда один или несколько клиентов открывают слишком много одновременных подключений к серверу, не позволяя другим клиентам устанавливать новые соединения.

Клиенты Blazor устанавливают единое соединение за сеанс и сохраняют подключение открытым до тех пор, пока окно браузера открыто. Требования к серверу обслуживания всех подключений не специфичны для приложений Blazor. Учитывая постоянный характер подключений и состояние приложений Blazor Server, исчерпание связи является большим риском для доступности приложения.

По умолчанию количество подключений на одного пользователя для приложения Blazor Server не ограничено. Если приложение требует ограничения соединения, возьмите один или несколько из следующих подходов:

* Требуется аутентификация, что, естественно, ограничивает возможность несанкционированного подключения пользователей к приложению. Для того чтобы этот сценарий был эффективным, пользователи должны быть лишены возможности подготовить новых пользователей по своей воле.
* Ограничьте количество подключений на пользователя. Ограничение соединений может быть достигнуто с помощью следующих подходов. Упражнение, чтобы позволить законным пользователям получить доступ к приложению (например, когда установлен лимит соединения на основе IP-адреса клиента).
  * На уровне приложения:
    * Расширяемость конечных точек.
    * Требуется аутентификация для подключения к приложению и отслеживания активных сеансов на пользователя.
    * Отклонить новые сессии по достижении предела.
    * Прокси WebSocket подключается к приложению с помощью прокси- и прокси, такой как [служба Azure SignalR,](/azure/azure-signalr/signalr-overview) которая мультиплексирует подключение клиентов к приложению. Это обеспечивает приложение с большей емкостью соединения, чем один клиент может установить, предотвращая клиента от исчерпания соединений с сервером.
  * На уровне сервера: Используйте прокси/шлюз перед приложением. Например, [Azure Front Door](/azure/frontdoor/front-door-overview) позволяет определять, управлять и контролировать глобальную передвижение веб-трафика в приложение.

## <a name="denial-of-service-dos-attacks"></a>Атаки типа «отказ в обслуживании» (DoS)

Отказ в обслуживании (DoS) атаки связаны с клиентом, заставляя сервер исчерпать один или несколько своих ресурсов, что делает приложение недоступным. Приложения Blazor Server включают некоторые ограничения по умолчанию и полагаются на другие ограничения ASP.NET core и SignalR для защиты от DoS-атак:

| Лимит приложения Blazor Server                            | Описание | Значение по умолчанию |
| ------------------------------------------------------- | ----------- | ------- |
| `CircuitOptions.DisconnectedCircuitMaxRetained`         | Максимальное количество отключенных цепей, которые данный сервер удерживает в памяти одновременно. | 100 |
| `CircuitOptions.DisconnectedCircuitRetentionPeriod`     | Максимальное количество времени, когда отключенная цепь удерживается в памяти перед тем, как быть снесенной. | 3 минуты |
| `CircuitOptions.JSInteropDefaultCallTimeout`            | Максимальное время сервера ждет до синхронизации асинхронного вызова функции JavaScript. | 1 минута |
| `CircuitOptions.MaxBufferedUnacknowledgedRenderBatches` | Максимальное количество неподтвержденных пакетов рендеров, которые сервер сохраняет в памяти на каждую цепь в данный момент времени для поддержки надежного переподключения. После достижения предела сервер прекращает производство новых партий рендеров до тех пор, пока одна или несколько партий не будут признаны клиентом. | 10 |


| SignalR и ASP.NET основных пределов             | Описание | Значение по умолчанию |
| ------------------------------------------ | ----------- | ------- |
| `CircuitOptions.MaximumReceiveMessageSize` | Размер сообщения для отдельного сообщения. | 32 КБ |

## <a name="interactions-with-the-browser-client"></a>Взаимодействие с браузером (клиент)

Клиент взаимодействует с сервером через JS interop отправки событий и завершения. JS interop связи идет в обоих направлениях между JavaScript и .NET:

* События браузера отправляются от клиента к серверу асинхронным способом.
* Сервер реагирует асинхронно rerendering uI по мере необходимости.

### <a name="javascript-functions-invoked-from-net"></a>Функции JavaScript, вызванные из .NET

Для звонков от методов .NET до JavaScript:

* Все вызовы имеют настраиваемый тайм-аут, после <xref:System.OperationCanceledException> которого они терпят неудачу, возвращая сью к вызывающему абоненту.
  * Там в по умолчанию тайм-аут для звонков ()`CircuitOptions.JSInteropDefaultCallTimeout`в одну минуту. Чтобы настроить этот предел, см. <xref:blazor/call-javascript-from-dotnet#harden-js-interop-calls>
  * Токен отмены может быть предоставлен для контроля за отменой на основе по счету. По умолчанию тайм-аут вызова по умолчанию, где это возможно, и ограниченный по времени любой звонок клиенту, если предоставляется токен отмены.
* Результатвызова вызова JavaScript нельзя доверять. Клиент Blazor приложения, работающий в браузере, ищет функцию JavaScript для ввода. Функция вызывается, и либо результат, либо ошибка производится. Злоумышленник может попытаться:
  * Причина проблемы в приложении, вернув ошибку из функции JavaScript.
  * Вызвать непреднамеренное поведение на сервере, вернув неожиданный результат из функции JavaScript.

Примите следующие меры предосторожности, чтобы остерегаться предыдущих сценариев:

* Оберните вызовы JS interop в [инструкциях try-catch](/dotnet/csharp/language-reference/keywords/try-catch) для учета ошибок, которые могут возникнуть во время вызовов. Для получения дополнительной информации см. <xref:blazor/handle-errors#javascript-interop>.
* Проверка данных, возвращенных из вызовов JS interop, включая сообщения об ошибках, перед принятием каких-либо действий.

### <a name="net-methods-invoked-from-the-browser"></a>Методы .NET, вызванные из браузера

Не доверяйте вызовам от методов JavaScript к .NET. При воздействии метода JavaScript метода .NET подумайте о том, как вызывается метод .NET:

* Относитесь к любому методу .NET, подверженным JavaScript, как к публичной конечной точке приложения.
  * Проверка ввода.
    * Убедитесь, что значения находятся в пределах ожидаемых диапазонов.
    * Убедитесь, что пользователь имеет разрешение на выполнение запрошенного действия.
  * Не выделяйте чрезмерное количество ресурсов в рамках вызова метода .NET. Например, выполните проверки и уместите ограничения на использование процессора и памяти.
  * Примите во внимание, что статические и экземплярные методы могут быть подвержены воздействию клиентов JavaScript. Избегайте совместного использования состояния между сеансами, если в проекте не содержится призывки к совместному использованию состояния с соответствующими ограничениями.
    * Например, методы, подвергающиеся воздействию `DotNetReference` объектов, которые первоначально создаются в результате инъекции зависимости (DI), объекты должны быть зарегистрированы в качестве объектов, на которые будут созданы. Это относится к любой Blazor службе DI, которую использует приложение Server.
    * Для статических методов избегайте создания состояния, которое не может быть передано клиенту, если приложение явно не делится по-своему состоянием между всеми пользователями на экземпляре сервера.
  * Избегайте передачи данных, предоставленных пользователями в параметрах, вызовам JavaScript. Если передача данных по параметрам абсолютно необходима, убедитесь, что код JavaScript обрабатывает передачу данных без введения уязвимостей [кросс-сайтных скриптов (XSS).](#cross-site-scripting-xss) Например, не записывайте данные, предоставленные пользователем, `innerHTML` в модель объекта документа (DOM), установив свойство элемента. Рассмотрите возможность использования [политики безопасности содержимого (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP) для отстранивания `eval` и других небезопасных примитивов JavaScript.
* Избегайте реализации пользовательской отправки вызовов .NET поверх реализации диспетчерской платформы. Разоблачение методов .NET в браузере является продвинутым сценарием, не рекомендованный для общей Blazor разработки.

### <a name="events"></a>События

События предоставляют точку Blazor входа в приложение Server. Те же правила защиты конечных точек в Blazor веб-приложениях применяются к обработке событий в приложениях Server. Злоумышленник может отправить любые данные, которые он хочет отправить в качестве полезной нагрузки для события.

Пример:

* Событие изменения для `<select>` может отправить значение, которое не входит в параметры, которые приложение представило клиенту.
* An `<input>` может отправлять любые текстовые данные на сервер, минуя проверку на стороне клиента.

Приложение должно проверить данные для любого события, которое обрабатывает приложение. Компоненты Blazor каркасных [форм](xref:blazor/forms-validation) выполняют основные проверки. Если приложение использует компоненты пользовательских форм, пользовательский код должен быть написан для проверки данных событий по мере необходимости.

BlazorСобытия сервера являются асинхронными, поэтому несколько событий могут быть отправлены на сервер до того, как приложение успеет отреагировать, создав новый рендер. Это имеет некоторые последствия для безопасности. Ограничение действий клиента в приложении должно выполняться внутри обработчиков событий и не зависеть от текущего состояния отобрасированного представления.

Рассмотрим встречный компонент, который должен позволить пользователю приравлить счетчик максимум в три раза. Кнопка для приращения `count`счетчика условно зависит от значения:

```razor
<p>Count: @count<p>

@if (count < 3)
{
    <button @onclick="IncrementCount" value="Increment count" />
}

@code 
{
    private int count = 0;

    private void IncrementCount()
    {
        count++;
    }
}
```

Клиент может отправить одно или несколько событий приращения до того, как платформа производит новый рендер этого компонента. В результате пользователь `count` может приравлять ее *более трех раз,* поскольку кнопка не удаляется пользовательским интерфейсом достаточно быстро. Правильный способ достижения предела `count` в три приращения показан в следующем примере:

```razor
<p>Count: @count<p>

@if (count < 3)
{
    <button @onclick="IncrementCount" value="Increment count" />
}

@code 
{
    private int count = 0;

    private void IncrementCount()
    {
        if (count < 3)
        {
            count++;
        }
    }
}
```

Добавляя `if (count < 3) { ... }` чек внутри обработчика, решение `count` о приращении основано на текущем состоянии приложения. Решение не основано на состоянии uI, как это было в предыдущем примере, которое может быть временно устаревшим.

### <a name="guard-against-multiple-dispatches"></a>Защитите от нескольких диспетчеров

Если обратный вызов события вызывает длительную операцию асинхронно, например, получение данных из внешней службы или базы данных, рассмотрите возможность использования охранника. Охранник может предотвратить пользователя от очереди до нескольких операций в то время как операция продолжается с визуальной обратной связи. Следующий компонент `isLoading` код `true` `GetForecastAsync` устанавливает в то время как получение данных с сервера. В `isLoading` `true`то время как, кнопка отключена в uI:

```razor
@page "/fetchdata"
@using BlazorServerSample.Data
@inject WeatherForecastService ForecastService

<button disabled="@isLoading" @onclick="UpdateForecasts">Update</button>

@code {
    private bool isLoading;
    private WeatherForecast[] forecasts;

    private async Task UpdateForecasts()
    {
        if (!isLoading)
        {
            isLoading = true;
            forecasts = await ForecastService.GetForecastAsync(DateTime.Now);
            isLoading = false;
        }
    }
}
```

Шаблон охраны, показанный в предыдущем примере, работает, если фоновая `async` - `await` операция выполняется асинхронно с шаблоном.

### <a name="cancel-early-and-avoid-use-after-dispose"></a>Отмена досрочно и избегайте использования после удаления

В дополнение к использованию охранника, как описано в <xref:System.Threading.CancellationToken> [разделе Охрана против нескольких диспетчеров,](#guard-against-multiple-dispatches) рассмотреть возможность использования для отмены длительных операций, когда компонент удаляется. Этот подход имеет дополнительное преимущество, избегая *использования после удаления* компонентов:

```razor
@implements IDisposable

...

@code {
    private readonly CancellationTokenSource TokenSource = 
        new CancellationTokenSource();

    private async Task UpdateForecasts()
    {
        ...

        forecasts = await ForecastService.GetForecastAsync(DateTime.Now, 
            TokenSource.Token);

        if (TokenSource.Token.IsCancellationRequested)
        {
           return;
        }

        ...
    }

    public void Dispose()
    {
        TokenSource.Cancel();
    }
}
```

### <a name="avoid-events-that-produce-large-amounts-of-data"></a>Избегайте событий, которые производят большие объемы данных

Некоторые события DOM, `oninput` `onscroll`такие как или могут создавать большой объем данных. Избегайте использования Blazor этих событий в приложениях сервера.

## <a name="additional-security-guidance"></a>Дополнительное руководство по безопасности

Рекомендации по обеспечению безопасности Blazor ASP.NET приложения Core применяются к приложениям Server и охватываются следующими разделами:

* [Регистрация и конфиденциальные данные](#logging-and-sensitive-data)
* [Защита информации в пути с помощью HTTPS](#protect-information-in-transit-with-https)
* [Кросс-сайт сценарий (XSS)](#cross-site-scripting-xss))
* [Защита от крестного происхождения](#cross-origin-protection)
* [Нажмите-джекинг](#click-jacking)
* [Открытые перенаправления](#open-redirects)

### <a name="logging-and-sensitive-data"></a>Регистрация и конфиденциальные данные

Взаимодействия Между клиентом и сервером JS интероп записываются <xref:Microsoft.Extensions.Logging.ILogger> в журналы сервера с экземплярами. Blazorизбегает регистрации конфиденциальной информации, такой как фактические события или вводы и выводы JS interop.

При возникновении ошибки на сервере фреймворк уведомляет клиента и срывает сеанс. По умолчанию клиент получает общее сообщение об ошибке, которое можно увидеть в инструментах разработчика браузера.

Ошибка на стороне клиента не включает стек вызовов и не содержит подробной информации о причине ошибки, но журналы сервера содержат такую информацию. Для целей разработки конфиденциальная информация об ошибках может быть доступна клиенту, включив подробные ошибки.

Включить подробные ошибки с:

* `CircuitOptions.DetailedErrors`.
* `DetailedErrors`конфигурация ключа. Например, установите переменную среды `ASPNETCORE_DETAILEDERRORS` на значение . `true`

> [!WARNING]
> Разоблачение информации об ошибках для клиентов в Интернете является угрозой безопасности, которую всегда следует избегать.

### <a name="protect-information-in-transit-with-https"></a>Защита информации в пути с помощью HTTPS

BlazorСервер SignalR используется для связи между клиентом и сервером. BlazorСервер обычно использует транспорт, который SignalR ведет переговоры, который обычно WebSockets.

BlazorСервер не обеспечивает целостность и конфиденциальность данных, отправляемых между сервером и клиентом. Всегда используйте HTTPS.

### <a name="cross-site-scripting-xss"></a>Кросс-сайт сценарий (XSS)

Кросс-сайт скриптов (XSS) позволяет несанкционированной стороне выполнять произвольные логики в контексте браузера. Скомпрометированное приложение потенциально может запустить произвольный код на клиенте. Уязвимость может быть использована для потенциального выполнения ряда вредоносных действий против сервера:

* Отправка поддельных/недействительных событий на сервер.
* Сбой диспетчерской отправки/недействительные завершения рендера.
* Избегайте отправки завершения рендеринга.
* Отправка интеропот звонков с JavaScript на .NET.
* Измените ответ на интероп-звонки с .NET на JavaScript.
* Избегайте отправки результатов .NET в JS interop.

Платформа Blazor Server принимает меры для защиты от некоторых предыдущих угроз:

* Прекращает выпуск новых обновлений uI, если клиент не признает партии рендеров. Настроен с `CircuitOptions.MaxBufferedUnacknowledgedRenderBatches`.
* Время из любого .NET на JavaScript вызова после одной минуты, не получая ответа от клиента. Настроен с `CircuitOptions.JSInteropDefaultCallTimeout`.
* Выполняет базовую проверку на всех входных данных, поступающих из браузера во время JS interop:
  * Ссылки .NET являются действительными и типа, ожидаемого методом .NET.
  * Данные не являются пороками.
  * Правильное количество аргументов для метода присутствует в полезной нагрузке.
  * Аргументы или результаты могут быть десериализованы правильно, прежде чем ссылаться на метод.
* Выполняет базовую проверку во всех входных данных, поступающих из браузера из рассылки событий:
  * Событие имеет действительный тип.
  * Данные для события могут быть десериализованы.
  * Обработчик событий связан с событием.

В дополнение к гарантиям, которые реализует платформа, приложение должно быть закодировано разработчиком для защиты от угроз и принятия соответствующих мер:

* Всегда проверяйте данные при обработке событий.
* Принять соответствующие меры при получении недействительных данных:
  * Игнорировать данные и возвращаться. Это позволяет приложению продолжать обработку запросов.
  * Если приложение определяет, что вход является незаконным и не может быть произведен законным клиентом, бросьте исключение. Бросая исключение срывает цепь и завершает сеанс.
* Не доверяйте сообщению об ошибке, предоставляемому завершением пакетов, включенных в журналы. Ошибка предоставляется клиентом и, как правило, не может быть доверено, так как клиент может быть скомпрометирован.
* Не доверяйте входным вызовам на JS interop в любом направлении между методами JavaScript и .NET.
* Приложение отвечает за проверку того, что содержание аргументов и результатов является действительным, даже если аргументы или результаты правильно десериализованы.

Для того чтобы уязвимость XSS существовала, приложение должно включать пользовательский ввод в отрисованную страницу. BlazorКомпоненты сервера выполняют этап компиляции времени, в котором разметка в файле *.razor* преобразуется в процедурную логику C. Во время выполнения логика C's создает *дерево рендеров,* описывающее элементы, текст и компоненты ребенка. Это применяется к DOM браузера через последовательность инструкций JavaScript (или сериализованв к HTML в случае prerendering):

* Пользовательский ввод, отображаемый `@someStringValue`через обычный синтаксис Razor (например, ) не предоставляет уязвимость XSS, потому что синтаксис Razor добавляется в DOM с помощью команд, которые могут писать только текст. Даже если значение включает html разметку, значение отображается как статический текст. При предварительном рендеринге вывод кодируется HTML, который также отображает содержимое как статический текст.
* Теги скриптов не допускаются и не должны быть включены в дерево визы компонента приложения. Если тег скрипта включен в разметку компонента, генерируется ошибка времени компиляции.
* Авторы компонентов могут авторить компоненты в СЗ без использования Razor. Автор компонента отвечает за использование правильных AIS при выходе. Например, `builder.AddContent(0, someUserSuppliedString)` использовать, а *не,* `builder.AddMarkupContent(0, someUserSuppliedString)`как последний может создать уязвимость XSS.

В рамках защиты от атак XSS рассмотрите возможность внедрения мер по смягчению последствий XSS, таких как [политика безопасности содержимого (CSP).](https://developer.mozilla.org/docs/Web/HTTP/CSP)

Для получения дополнительной информации см. <xref:security/cross-site-scripting>.

### <a name="cross-origin-protection"></a>Защита от крестного происхождения

Атаки кросс-происхождения связаны с клиентом другого происхождения, выполняющим действие против сервера. Вредоносное действие, как правило, запрос GET или форма POST (Кросс-сайт Запрос подделка, CSRF), но открытие вредоносного WebSocket также возможно. BlazorПриложения сервера предлагают [те же SignalR гарантии, что любое другое приложение, используюеееееее протокол концентратора:](xref:signalr/security)

* BlazorПриложения сервера могут быть доступны для перекрестного происхождения, если не будут приняты дополнительные меры для его предотвращения. Чтобы отключить доступ к кросс-происхождению, либо отключите CORS в конечной точке, `DisableCorsAttribute` добавив Blazor промежуточное программное обеспечение CORS в конвейер и добавив в конечную точку метаданные или ограничивайте набор разрешенных истоков путем [настройки SignalR для совместного использования ресурсов между корнями.](xref:signalr/security#cross-origin-resource-sharing)
* Если CORS включен, могут потребоваться дополнительные шаги для защиты приложения в зависимости от конфигурации CORS. Если CORS включен глобально, CORS может Blazor быть отключен для `DisableCorsAttribute` концентратора Server, добавив `hub.MapBlazorHub()`метаданные в метаданные конечных точек после вызова.

Для получения дополнительной информации см. <xref:security/anti-request-forgery>.

### <a name="click-jacking"></a>Нажмите-джекинг

Click-jacking включает визуализацию сайта `<iframe>` как внутри сайта другого происхождения, чтобы обмануть пользователя в выполнении действий на сайте, подвергаемому атакой.

Для защиты приложения от рендеринга внутри `<iframe>`содержимого используйте политику [безопасности содержимого (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP) и `X-Frame-Options` заголовок. Для получения дополнительной [информации см. веб-документы MDN: X-Frame-Options](https://developer.mozilla.org/docs/Web/HTTP/Headers/X-Frame-Options).

### <a name="open-redirects"></a>Открытые перенаправления

При Blazor запуске сеанса приложения Server сервер выполняет базовую проверку URL-адресов, отправленных в рамках запуска сеанса. Платформа проверяет, что базовый URL является родительским URL-адресом перед созданием схемы. Дополнительные проверки в рамках не проводятся.

Когда пользователь выбирает ссылку на клиенте, URL-адрес ссылки отправляется на сервер, который определяет, какие действия следует предпринять. Например, приложение может выполнять навигацию на стороне клиента или указывать браузеру для переопределения в новое место.

Компоненты могут также запускать навигационные `NavigationManager`запросы программно с помощью . В таких сценариях приложение может выполнять навигацию на стороне клиента или указывать браузеру для переопределения в новое место.

Компоненты должны:

* Избегайте использования пользовательского ввода как части аргументов навигационных вызовов.
* Проверка аргументов, чтобы убедиться, что цель разрешена приложением.

В противном случае злоумышленник может заставить браузер перейти на сайт, контролируемый злоумышленником. В этом случае злоумышленник уловки приложение в использовании некоторых пользовательских `NavigationManager.Navigate` ввода как часть вызова метода.

Этот совет также применяется при визуализации ссылок как часть приложения:

* Если возможно, используйте относительные ссылки.
* Проверить, что абсолютные направления ссылки действительны, прежде чем включить их в страницу.

Для получения дополнительной информации см. <xref:security/preventing-open-redirects>.

## <a name="authentication-and-authorization"></a>Аутентификация и авторизация

Для получения рекомендаций по <xref:security/blazor/index>аутентификации и авторизации см.

## <a name="security-checklist"></a>Контрольный список по безопасности

Следующий список соображений безопасности не является исчерпывающим:

* Проверка аргументов из событий.
* Проверка входных данных и результатов вызовов JS interop.
* Избегайте использования (или проверки) пользовательского ввода для вызовов .NET к interop JS.
* Предотвратите выделение клиенту неограниченного объема памяти.
  * Данные внутри компонента.
  * `DotNetObject`ссылки возвращены клиенту.
* Защитите от нескольких диспетчеров.
* Отмена длительных операций при удалении компонента.
* Избегайте событий, которые производят большие объемы данных.
* Избегайте использования пользовательского ввода `NavigationManager.Navigate` как части вызовов и проверки пользовательских ввода для URL-адресов в отношении набора разрешенных истоков, если это неизбежно.
* Не принимать решения о авторизации на основе состояния пользователя, а только из состояния компонента.
* Для защиты от атак XSS можно использовать [политику безопасности содержимого (CSP).](https://developer.mozilla.org/docs/Web/HTTP/CSP)
* Рассмотрите возможность использования CSP и [X-Frame-Options](https://developer.mozilla.org/docs/Web/HTTP/Headers/X-Frame-Options) для защиты от кликов.
* Убедитесь, что настройки CORS являются уместными при Blazor включении CORS или явном отключить CORS для приложений.
* Проверьте, чтобы ограничения на сервер Blazor для приложения обеспечивали приемлемый пользовательский опыт без неприемлемых уровней риска.
